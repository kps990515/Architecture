## SOA(Service oriented) Architecture
 - 애플리케이션을 독립적인 서비스들의 조합으로 구성하는 아키텍처 스타일
 - MSA의 시작

## SOA와 MSA의 차이점

| 항목 | SOA (Service-Oriented Architecture) | MSA (Microservices Architecture) |
|------|----------------------------------|----------------------------------|
| **서비스 크기** | 비교적 크고, 여러 기능이 포함될 수 있음 | 작고 독립적인 서비스로 구성 |
| **통신 방식** | 주로 ESB를 활용한 SOAP, XML 기반 통신 | 경량화된 REST API, gRPC, 메시지 큐 활용 |
| **데이터 저장소** | 서비스 간 공유 DB 사용 가능 | 각 서비스가 개별 DB를 가짐 (Database per Service) |
| **배포 방식** | 전체적인 배포 및 통합 관리 | 독립적 배포 가능, 컨테이너 기반 배포 (Docker, Kubernetes) |
| **성능** | ESB를 통한 중앙 집중형이므로 성능 저하 가능 | 개별 서비스 간 직접 통신으로 성능 향상 가능 |
| **유연성** | 기존 레거시 시스템과 연계가 용이 | 빠른 개발과 확장이 가능하지만 운영 복잡성이 증가 |

### IT시스템 아키텍쳐의 변화
 - MainFrame(Cobol) : 업무자동화
 - Client-Server(SQL, Visual-basic): 데스크탑
 - N-Tier model and the Web(OOP) : 인터넷 비즈니스
 - Service Oriented : 비즈니스 적응력

### SAO 아키텍처란
 - 기존의 애플리케이션의 기능들을 비즈니스 기능 단위로 묶어서 
 - 표준화된 호출 인터페이스를 통해서
 - 서비스로 구현
 - 이런 서비스들을 조합하여 애플리케이션을 구성

### SOA가 주목받았던 이유
 - 분산 기술의 표준화 필요성
 - 업무 시스템 확장에 따른 통합 필요성
 - IT시스템 업무 변화 민첩성에 대한 요구

### 서비스란
 - 플랫폼에 종속되지 않는 표준 인터페이스를 통해 기업의 업무를 표현한
 - 커플링이 적고 상호 조합 가능한 소프트웨어 컴포넌트
 - 서비스 인터페이스 : API

### 서비스 특징
 - 수직분할 : 서비스별 분할
 - 스탠다드 인터페이스(XML)
 - Loosely coupled
 - Coarse grained : 여러 기능을 하나의 API에서 제공(고객의 기본 정보 + 계좌 목록 + 최근 거래 내역)
 - Discoverable : 어떤 서비스가 있는지 확인 가능

### 서비스 구성
 - 서비스 규약 : 서비스 목록, 호출인자, 데이터 타입 등 정의
 - 서비스 인터페이스
 - 서비스 구현체

### 서비스 분류
 - 비즈니스 서비스
   - 태스트 지향 서비스 : 비즈니스 로직 제공
   - 데이터 지향 서비스 : 데이터 조회 변경을 담당
   - DDD로 나눔
 - Intermediary 서비스 : 기존 코드 변경 없이 아키텍처에 유연성을 더해주는 서비스
   - 중간 다리로 기능 추가
   - 라우팅
   - 메시지 변환
 - 프로세스 센트릭 서비스
   - 기존 비지니스 서비스를 조합하여, 비지니스 시나리오를 구현
   - 긴 업무 프로세스 구현
   - 상태정보 포함 가능
 - 애플리케이션 서비스 : 비즈니스가 아닌 테크니컬 기능 구현
   - 오토스케일링, 모니터링
 - 연동 서비스 : 타 시스템이나 외부 시스템 연동

### SOA 단계적 발전 구조
 - Fundamental SOA : 기존 시스템들을 서비스화하여 통합하는 단계
   - 서비스화가 목적
   - 서비스에 대한 조합은 프론트엔드에서 담당
   - 비즈니스 서비스로만 구성
   - 현대의 MSA와 가장 비슷
 - Networed SOA 
   - Fundamental SOA가 커지면서 연결이 복잡해지면서 시스템 유연성이 떨어짐
   - 거미줄식 연결을 중앙에 버스(ESB)를 넣어서 Hub & Spoke 형태 구조 제공
   - Intermediary 서비스를 ESB에 배포해 아키텍쳐의 유연성 확보
   - ESB(라우팅, 변환, 로깅, 서비스통제)가 점점 커짐
 - Process Oriented SOA 
   - 여러개의 서비스를 조합하여 하나의 복잡합 업무를 구현
   - 서비스 조합(오케스트레이션)을 위한 BPM(Business Process Management)과 같은 워크 플로우 엔진을 별도로 도입
 
### SOA 수행전략
   - 하나의 SOA시스템에 비즈니스 전략에 따라 기능을 추가
   - 전체 기업 업무를 단일 시스템으로 운영하기 위한 플랫폼이 필요
   - 거버넌스 : 제어통제
     - SOA 정책 수립 및 표준화
     - 기술 전파 및 가이드
     - 구축 계획 수립 및 실행
   - 비용통제
     - 초기에는 많은 비용 소요
     - 서비스를 재사용, 재조합함으로서 개발 비용이 감소
   - 프로젝트 진행
     - 반복적 개발 모델 : 개발, 운영하면서 점진적으로 서비스를 개선 및 변경

### SOA 실패 요인
 - 복잡한 기술
   - XML/WebSerivce는 모든 기능을 표준화 스펙화 하려고함
   - 결과적으로 복잡도 증가, 학습비용 증가
   - 일반적인 SI가 최적화된 코드개발이 어려움
   - 현재 : REST/JSON으로 쉽고, 직관적인 인터페이스 제공
 - Enterprise Service Bus
   - 개념은 좋지만 SPOF로 작용
   - XML/SOAP 파싱비용이 높아서 성능 병목 발생
   - 너무 많은 Intermediary Serivce 로직
   - 현재
     - API gateway, Service Mash 
       - REST/JSON으로 경량화 하고, 최소한의 기능만 유지
       - 외부 API 서비스 컨트롤 및 내부간 서비스컨트롤을 API gateway, Service Mash로 나눔
       - ServiceMesh(마이크로서비스 간의 통신을 제어하고 관리하는 인프라 계층)는 분산화 구조 
     - Event Driven Architecture
       - ESB 아키텍쳐 구조 자체는 좋으나 어려움
       - Netflix등에서는 사용
 - 중앙집중 거버넌스
   - 조직마다 다른 이해관계
   - 커뮤니케이션 비용 증가
   - 시스템 복잡해짐
   - 현재 : 분산형 거버넌스(민첩성 증가, 이해관계 분리, 자치권 부여)

