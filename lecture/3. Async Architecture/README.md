## Async Architecture

### 동기 VS 비동기(작업완료 여부)
  - 동기 : 작업 완료 여부를 기다림
  - 비동기 : 작업 완료 여부 상관없이 다음 작업 실행

### 블로킹 VS 논블로킹(제어권 여부)
  - 블로킹 : 호출자가 처리자에게 처리권한을 넘겨 아무 처리도 할 수 없는 상태
  - 논브로킹 : 호출 후 권한을 다시 반환받아 다른 작업 수행 가능

### 비동기 처리
  - 메세지 큐를 기반 (MQ, RABBIT MQ,KAFKA, SQS etc)
  - 요청을 받아 큐에 적재
  - 큐 뒤에 다수의 워커가 메세지를 읽어서 처리 (워커수를 조정하여 대용량 처리가 용이)
  - 요청자는 요청 후 다른 작업 수행 가능

### 비동기 처리 패턴
  - FIRE & FORGET : 큐에만 넣음 (작업완료 보장 안됨)
  - PUBLISH & SUBSCRIBE : 큐에 넣으면 각 큐에 맞는 Subscriber가 읽어감
  - ROUTING : 큐에 담긴 메시지에 따라 Worker에 라우팅

### 비동기 에러 처리 패턴
  - Error Hospital : worker에서 에러 발생할 시 에러큐에 전달 -> 재시도 / 무시 / 리포팅
  - 보통 재시도 후 안되면 사람에게 리포팅해서 차후 재처리
  - 메시지 유실이 되면 안되는 엔터프라이즈 시스템에서 많이 사용

### 메시지 큐 종류
  - 확장 가능한 분산 큐 : Kafka, Google Pub/Sub
  - 확장 불가능 큐 : Redis, Rabbit MQ, Active MQ
  - XA 기반 트랜잭션 지원 : IBM MQ, Active MQ
  - 가장 일반적인 큐 : Redis, Kafka, Rabbit MQ
  - 메시지큐는 대부분 메모리에 메시지 저장 -> 확장불가능 큐의 경우 OOM으로 죽음 -> 이 경우 DISK나 외부 DB에 저장

### 메시지 큐 디자인시 주의사항
  1. 순차 보장 : 메시지를 클라이언트가 보낸 순서대로 도착해야 한다.
     - 메시지를 동일한 큐로 보내고, 단일 소비자를 사용하는 방식으로 처리
  2. 메시지 중복 처리: 네트워크 문제나, retry 과정에서 동일한 메시지가 전달되는 경우
     - 메시지 ID 를 기반으로 Consumer에서 기록을 유지해서 비교
     - Consumer에서 idempotent를 유지하도록 설계 (ex update)
  3. 메시지 유실방지 : 비정상종료,네트워크문제, 큐의 TTL timeout등
     - Persistent disk또는 DBMS에 메시지를 저장
     - ACK를 사용하여 메시지가 성공 처리되었음을 저장
     - 에러큐를 이용하여, 비정상 메시지에 대한 처리
  4. 메시지 크기 : 큰 메시지는 성능 저하와 OOM을 유발
     - 대용량 데이터는 별도의 스토리지에 저장 (NFS,S3 etc)하고 메타 정보만 큐에 저장
  5. TTL 설정 : 오래된 메시지가 시스템에 남아서 메모리와 디스크를 낭비하는 것을 방지
     - 메시지큐의 TTL을 적절히 설정
     - 만료된 메시지를 에러큐로 보내거나, 삭제

### 공유파일 시스템
  - 보통 메시지는 메시지 큐를 통해서 전달
  - 메시지가 큰 경우 (이미지 파일,비디오), 메타 정보만 메시지 큐를 통해서 전달 
  - 메시지 바디는 별도의 공유 파일 시스템을 통해서 전달한다. (메시지 메타 정보에 파일 경로 저장)
  - HPC, 머신러닝에도 사용됨

### 공유 파일 시스템 종류
  - NFS(잘안씀)
    - 장점 : 장점 : Linux 배포판에 기본 탑재됨, 사용이 편리함
    - 단점 : 확장성 부족, 성능 저하
    - 용도 : 소규모 네트워크 파일 공유
  - NFS appliance
    - 장점 : OSS NFS에 비하여 빠른 성능
    - 단점 : 확장성 부족 (100~500TB),가격이 매우 높음
    - 용도 : HPC, 일부 DB 등 다양한 시나리오 사용 가능
  - Blob(AWS S3, GCP GCS etc)
    - 장점 : 대용량, 저비용
    - 단점 : 느림 (SSD(VM) Local 캐쉬로 어느정도 해결 가능)
    - 용도 : 대용량 파일 저장
  - 병렬 스토리지 (DAOS, Lustre)
    - 장점 : 대용량, 매우 빠름
    - 단점 : 러닝 커브가 매우 높고, 운영이 어려움
    - 용도 : 대규모 머신러닝 학습 및 HPC



